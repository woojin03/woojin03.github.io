---
layout: post
title:  SQLD 자격증 준비 (2일차)
author: leewoojin
date: 2025-05-09 00:00:00 +0900
categories: [자격증, SQLD]
tags: []
---

<img width="346" alt="Image" src="https://github.com/user-attachments/assets/8f816294-7f80-4a62-bbdb-5035c4b8f0cd" />

1과목 다 맞아야 60점으로 시험 통과하는 건데... 그래도 어제보단 성장했다 ㅎ

## 1과목 

### 3번 문제  
다음은 도메인에 대한 설명이다. **특징으로 알맞지 않은 것**은?

① 속성을 명사로 분리한다.  
② 공통으로 발생하는 명사는 여러 개의 도메인으로 생성한다.  
③ 각 엔터티 속성에 도메인을 할당한다.  
④ 도메인별로 데이터 타입과 길이를 지정한다.  

<details>
  <summary>✅ 정답 </summary>

  **정답: ②**

  공통 명사는 **하나의 도메인으로 정의하여 재사용**하는 것이 원칙입니다.  
  여러 개로 나누면 일관성이 떨어지고 유지보수가 어려워집니다.
</details>

### 도메인 정의의 핵심 특징

| 항목 | 설명 |
|------|------|
| **속성 분리** | 속성은 명사형으로 구분하며, 의미를 명확하게 정의합니다. |
| **도메인 재사용** | 동일 의미의 값은 동일한 도메인으로 **일관성 있게 관리**합니다. |
| **속성과 도메인의 연결** | 각 속성은 반드시 하나의 도메인을 참조해야 합니다. |
| **데이터 타입 지정** | 도메인별로 타입, 길이, 제약조건(Null, 유효값 등)을 정의합니다. |

### 내가 헷갈린 포인트

| 구분                       | 의미                  | 품사적 성격 | 예시                 | 설명                             |
| ------------------------ | ------------------- | ------ | ------------------ | ------------------------------ |
| **1. 관계 (Relation)**     | **테이블(표)**          | 명사     | `고객` 테이블, `주문` 테이블 | 관계형 데이터베이스(RDB)의 핵심 구성요소       |
| **2. 관계 (Relationship)** | **엔터티 간의 연결 또는 행위** | 동사     | 고객은 주문한다           | 개념적 데이터 모델(ERD)의 요소, 관계선으로 표현됨 |

---

### 6번 문제  
다음 중 **엔터티(Entity)** 의 특징에 포함되지 않는 것은?

① 엔터티는 업무 프로세스에 의해 이용되어야 한다.  
② 엔터티는 속성이 없어도 된다.  
③ 유일한 식별자에 의해 식별이 가능해야 한다.  
④ 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이어야 한다.  

<details>
  <summary>✅ 정답 </summary>

  **정답: ②**

  엔터티는 **최소 2개 이상의 속성을 가져야 하며**,  
  그 중 하나는 **유일한 식별자(Primary Key)** 로 존재해야 합니다.  
  속성이 없는 엔터티는 데이터를 표현할 수 없기 때문에 엔터티로 간주하지 않습니다.
</details>

### ✅ 엔터티의 기본 특징

| 기준 | 설명 |
|------|------|
| **업무 연관성** | 해당 도메인의 업무에서 **관리할 필요가 있는 정보**여야 합니다. |
| **속성 보유** | 최소 **2개 이상의 속성(컬럼)** 을 가져야 하며, 그중 하나는 **식별자(PK)** 여야 합니다. |
| **식별 가능성** | 엔터티의 각 인스턴스는 **고유하게 식별 가능**해야 합니다. |
| **프로세스와의 연계** | 단순 보관이 아닌, **업무 흐름 속에서 사용되는 정보**여야 의미가 있습니다. |
---

### 7번 문제  
어느 기업의 직원 테0|블(EMP)이 직급(GRADE) 별로 사원 500명, 대리 100명, 과장 30명, 차장 10명, 부장 5명, 직급이 정해지지 않은 (NULL) 사람 25명으로 구성되어 았을 때, 다음 중 SQL문을 SQL1)부터 SQL3)까지 순차적으로 실행한 결과 건수를 순서대로 나열한 것으로 가장 적절한 것은?


![Image](https://github.com/user-attachments/assets/b4926d04-a285-4690-8720-d5a37e49c821)

  1. 670, 40, 6  
  2. 645, 15, 6  
  3. 645, 40, 5  
  4. 670, 15, 5  


<details>
  <summary>✅ 정답 </summary>

  **정답: ②**

   SQL1: `COUNT(GRADE)` 
- COUNT(GRADE)는 NULL 값을 제외한 GRADE 컬럼의 개수를 셉니다.

 SQL2: `GRADE IN ('차장', '부장', '널')`
- '널'은 문자열 '널'로 간주되어 실제 NULL은 포함되지 않음

 SQL3: `GROUP BY GRADE`  
- GROUP BY는 NULL 값을 하나의 그룹으로 포함합니다.

  | 단계 | 결과값 | 해석 |
  |------|--------|------|
  | SQL1 | 645명 | NULL이 아닌 GRADE 보유자 |
  | SQL2 | 15명 | 특정 고위 직급(차장, 부장 등) 인원만 필터링 |
  | SQL3 | 6개 | DISTINCT GRADE 값 종류가 6개로 파악됨 |

</details>

### 2과목 
### 17번 문제  
다음의 SQL문에 대한 설명으로 **올바르지 않은 것**은?

- ㄱ : `SELECT SUM(SAL) FROM EMP GROUP BY DEPTNO;`  
- ㄴ : `SELECT SUM(SAL) FROM EMP GROUP BY ROLLUP(DEPTNO);`

1. ㄱ의 SQL문은 전체합계는 출력되지 않는다.  
2. ㄴ은 부서별 합계와 전체합계가 출력된다.  
3. ㄱ과 ㄴ의 결과 행 수는 동일하다.  
4. ㄱ은 부서별 합계를 출력한다. 

<details>
  <summary>✅ 정답 </summary>

  **정답: ③**

  - **ㄱ SQL:**  
    `GROUP BY DEPTNO`는 부서별 SAL 합계를 출력  
    → 예: 부서 10, 20, 30 각각의 합계만 출력됨  
    → **전체합계는 나오지 않음**

  - **ㄴ SQL:**  
    `GROUP BY ROLLUP(DEPTNO)`은  
    → 부서별 SAL 합계 + 전체합계(마지막 행) 출력  
    → 총 행 수는 부서 수 + 1

  - 예를 들어 부서가 3개라면:
    - ㄱ은 **3행**
    - ㄴ은 **4행 (부서별 3 + 전체합계 1)**

  ### ✅ 결론 요약

  | SQL문 | 기능 | 결과 행 수 |
  |--------|------|--------------|
  | ㄱ (`GROUP BY DEPTNO`) | 부서별 합계 | 부서 수만큼 |
  | ㄴ (`GROUP BY ROLLUP(DEPTNO)`) | 부서별 + 전체 합계 | 부서 수 + 1 |

  따라서 "ㄱ과 ㄴ의 결과 행 수는 동일하다"는 보기 ③은 **틀린 설명**이다.

</details>

### 18번 문제  
주어진 SQL문을 수행한 결과로 **올바른 것**은?

INSERT INTO test24 VALUES (1); INSERT INTO test24 VALUES (2); COMMIT; INSERT INTO test24 VALUES (3); SAVEPOINT SP; INSERT INTO test24 VALUES (4); ROLLBACK to SP; SELECT COUNT(*) FROM test24;`

1. 6 
2. 5
3. 3
4. 2

<details>
  <summary>✅ 정답 </summary>

  **정답: ③**

</details>

### 내가 헷갈린 포인트
```spl
SELECT COUNT(*) FROM test24;
```
테이블에 저장된 레코드의 수를 반환 
- 예: 행이 3개면 → 결과는 3

```spl
SELECT COUNT(*) FROM test24;
```
 지정한 컬럼(col1)의 모든 값을 더한 합을 반환 
- 예: 값이 1, 2, 3이면 → 결과는 6 

---
### 19번 문제  
다음 중 **DDL 문이 아닌 것**은?

1. ALTER  
2. COMMIT  
3. RENAME  
4. CREATE TABLE  

<details>
  <summary>✅ 정답 </summary>

  **정답: ②**

  - **DDL (Data Definition Language)**  
    → 데이터베이스의 **구조(스키마)** 를 정의하거나 변경하는 명령어 집합  
    → 주요 문법: `CREATE`, `ALTER`, `DROP`, `RENAME`, `TRUNCATE`

  - **TCL (Transaction Control Language)**  
    → 트랜잭션의 수행 결과를 **영구 저장하거나 복구**하는 명령어  
    → 대표 명령어: `COMMIT`, `ROLLBACK`, `SAVEPOINT`  

</details>


  ### ✅ 분류표

| 분류                                        | 설명             | 대표 명령어                                          |
| ----------------------------------------- | -------------- | ----------------------------------------------- |
| **DDL**<br>(Data Definition Language)     | **구조 정의 및 변경** | `CREATE`, `ALTER`, `DROP`, `RENAME`, `TRUNCATE` |
| **DML**<br>(Data Manipulation Language)   | **데이터 조작**     | `INSERT`, `UPDATE`, `DELETE`                    |
| **DCL**<br>(Data Control Language)        | **권한 제어**      | `GRANT`, `REVOKE`                               |
| **TCL**<br>(Transaction Control Language) | **트랜잭션 제어**    | `COMMIT`, `ROLLBACK`, `SAVEPOINT`               |
| **DQL**<br>(Data Query Language)          | **데이터 조회**     | `SELECT`                                        |

---

### 27번 문제  
CASE문에서 **ELSE를 생략하면** 어떤 현상이 발생되는가?

① ELSE 조건이 만족하게 되면 NULL이 된다.  
② ELSE 조건을 만족하게 되면 무시한다.  
③ ELSE 조건이 만족하게 되면 공집합이 리턴된다.  
④ ELSE를 생략하고 작성하면 실행 시 ELSE 조건이 참이 되며 오류가 발생한다.  

<details>
  <summary>✅ 정답 </summary>

  **정답: ①**
  CASE 문에서 ELSE를 생략하고 어떤 조건도 만족하지 않으면,
SQL은 명시적 반환값이 없다고 판단하고 NULL을 반환한다.
</details>

### 30번 문제  
아래의 계층형 SQL에서 **리프 노드이면 1, 그렇지 않으면 0**을 출력하고 싶을 때 사용하는 키워드로 **알맞은 것**은?

SELECT LEVEL, EMPNO, MGR, _____________ AS 리프노드여부  
FROM SCOTT.EMP  
START WITH MGR IS NULL  
CONNECT BY PRIOR EMPNO = MGR;


1. CONNECT_BY_ROOT  
2. SYS_CONNECT_BY_PATH  
3. CONNECT_BY_ISCYCLE  
4. CONNECT_BY_ISLEAF  

<details>
  <summary>✅ 정답 </summary>

  **정답: ④**

  - `CONNECT_BY_ISLEAF`는 Oracle의 계층형 쿼리에서 제공하는 **가상 컬럼**으로,  
    **각 행이 리프 노드인지 여부**를 알려줍니다.
  - 리프 노드란 **하위 자식이 없는 마지막 노드**를 의미하며, 다음과 같이 결과가 나타납니다:
    - 리프 노드일 경우 → `1`  
    - 자식 노드가 있으면 → `0`
</details>

###  계층형 질의에서 자주 사용되는 가상 컬럼

| 가상 컬럼                 | 의미                        | 암기 팁                                                      |
| --------------------- | ------------------------- | --------------------------------------------------------- |
| `LEVEL`               | 현재 노드의 **깊이**             | 🪜 **계단식 구조**니까 LEVEL!<br>→ 루트는 1, 아래로 내려갈수록 LEVEL 증가     |
| `CONNECT_BY_ROOT`     | 현재 행의 **최상위 루트 노드 값**     | 🌳 “**ROOT**에서 시작된 연결”<br>→ 맨 위 조상 노드를 기억하자               |
| `SYS_CONNECT_BY_PATH` | **루트부터 현재 노드까지의 경로** 문자열  | 🛤️ “**PATH** 따라 루트부터 현재까지”<br>→ 경로 문자열 (예: `/CEO/부장/과장`) |
| `CONNECT_BY_ISLEAF`   | **자식이 없는 리프 노드 여부** (1/0) | 🍃 리프노드(잎사귀)는 끝노드<br>→ **ISLEAF = 1**이면 마지막 노드            |
| `CONNECT_BY_ISCYCLE`  | **순환(cycle) 발생 여부** (1/0) | 🔁 “사이클이면 무한 루프!”<br>→ 자신을 참조하는 구조 탐지용                    |

---

### 32번 문제  
다음 ANSI 문법을 **Oracle 전용 조인 문법으로 바꾼 것 중** 가장 적절한 것은?

SELECT *  
FROM TAB1  
JOIN TAB2 ON TAB1.COL1 = TAB2.COL1  
LEFT OUTER JOIN TAB3 ON TAB1.COL2 = TAB3.COL2;


1. SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2(+);  
2. SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2(+);  
3. SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1(+) AND TAB1.COL2 = TAB3.COL2;  
4. SELECT * FROM TAB1, TAB2, TAB3 WHERE TAB1.COL1 = TAB2.COL1 AND TAB1.COL2 = TAB3.COL2;

<details>
  <summary>✅ 정답 </summary>

  **정답: ②**

  - ANSI SQL:
    - `JOIN TAB2 ON ...` → **INNER JOIN** (일반 등가조인)
    - `LEFT OUTER JOIN TAB3 ON ...` → TAB3가 없더라도 TAB1의 데이터는 **유지됨**
  
  - Oracle 조인 문법에서는 **OUTER JOIN을 받는 테이블의 조건에 `(+)` 기호**를 붙여야 합니다.

  - 따라서:
    - `TAB1.COL1 = TAB2.COL1` → 일반 조인 → **그대로**
    - `TAB1.COL2 = TAB3.COL2` → TAB3가 OUTER → **TAB3.COL2에 (+)**

  - 보기 ②는 그 조건을 정확히 반영하고 있음

</details>

### Oracle OUTER JOIN 변환 정리
- LEFT OUTER JOIN이면 → 오른쪽 테이블 컬럼에 `(+)`  
- RIGHT OUTER JOIN이면 → 왼쪽 테이블 컬럼에 `(+)`

---
### 44번 문제  
테이블 3개를 조인하려면 **최소 몇 개의 조건절**이 필요한가?

① 4  
② 3  
③ 2  
④ 1  

<details>
  <summary>✅ 정답 </summary>

  **정답: ③ (2)**

  - 테이블을 조인할 때는 **테이블 간 연결이 1:1로 필요**합니다.
  - 3개의 테이블을 모두 연결하려면 다음과 같은 구조가 필요합니다:  
    `A ↔ B ↔ C`  
    → **총 2개의 연결 = 2개의 조건절** (`ON` 또는 `WHERE`)

</details>

### N개의 테이블을 모두 조인하려면 필요한 조건 수 공식

  | 테이블 수 | 최소 조건절 수 |
  |------------|----------------|
  | 2 | 1 |
  | 3 | 2 |
  | 4 | 3 |
  | N | N - 1 |

---

